基于 React Native 和 React Native Web 构建一个类似 Ant Design Mobile 的跨端组件库是一项系统工程，需要精心设计架构、处理平台差异，并确保开发体验。下面是一套完整的技术方案，帮助你快速理解和实施。

# 🧱 跨端组件库技术方案

## 📋 目录
1.  **架构设计**
2.  **技术选型与初始化**
3.  **组件设计与开发规范**
4.  **样式方案**
5.  **跨平台适配策略**
6.  **工具链与构建配置**
7.  **文档与测试**
8.  **发布与部署**

## 1. 架构设计

构建跨端组件库的核心是**代码复用**和**平台适配**。

**核心原则**：**一次编写，多处运行**。大部分组件逻辑和样式应能在 React Native (iOS/Android) 和 Web 上共享。
**分层架构**：
**基础组件层**：提供最基础的 UI 构建块，如 `Box` (View/div)、`Text` (Text/span)。这些组件需要处理最核心的平台差异。
**复合组件层**：由基础组件组合而成，实现特定功能，如 `Button`、`Input`、`Tabs`。
**业务组件层**（可选）：基于复合组件，封装更复杂的、与业务逻辑相关的组件。
**跨端实现方案选择**：
要实现 React Native 组件在 Web 上运行，主要有几种方案，各有优劣：

| 特性 | react-native-web (RNW) | react-strict-dom (RSD) | react-native-react-bridge (RNRB) | 你的组件库 |
| :--- | :--- | :--- | :--- | :--- |
| **核心思路** | 将 RN API/组件转译为 DOM | 用 Web API 渲染，Polyfill 到 RN | WebView 作为桥梁，Web 和 RN 通信 | **基于 RNW，渐进式探索 RSD** |
| **性能** | 较好 | **理论上更优** | 受 WebView 性能限制 | 优先保证 RNW 性能 |
| **开发体验** | 学习 RN 语法 | **学习 Web 语法** | 需处理两端通信 | **统一的 RN 语法** |
| **包大小** | 较大 | **较小** | 需集成 Web 应用 | 依赖 RNW，需优化 |
| **适用场景** | 成熟的跨端项目 | **Meta 新标准，未来趋势** | 集成现有 Web 应用 | **新建组件库，追求未来兼容** |

**推荐选择**: **`react-native-web` (RNW)**。这是一个久经考验、广泛使用的方案，也是 Ant Design Mobile RN 使用的技术。它能将 React Native 的组件和 API 映射到 Web 的 DOM 和 CSS，是实现跨端最直接和稳定的方式。同时，可以密切关注 Meta 新开源的 `react-strict-dom`，它代表了另一种设计思路和未来的可能性。

## 2. 技术选型与初始化

**核心依赖**:
```bash
# 在你的组件库项目中
pnpm add react react-native --save # Peer Dependencies
pnpm add react-native-web --save # 跨端核心
pnpm add react-dom --save-dev # 用于 Web 端示例和文档开发
```
**构建工具**: 推荐使用 **TypeScript** 以获得更好的类型安全和开发体验。
```bash
pnpm add typescript @types/react @types/react-native --save-dev
```
**初始化项目结构**:
```
your-component-lib/
├── src/
│   ├── components/
│   │   ├── Button/
│   │   │   ├── index.tsx    # 主组件
│   │   │   ├── style.ts     # 样式
│   │   │   └── __tests__/   # 测试
│   │   ├── Tabs/
│   │   └── index.ts         # 统一导出所有组件
│   └── styles/
│       └── theme.ts         # 设计 token（颜色、间距、字体等）
├── docs/
│   └── index.html           # 文档网站入口
├── example/                 # 示例项目（RN 和 Web）
├── package.json
└── tsconfig.json
```

## 3. 组件设计规范

**统一接口**: 组件的 Props 设计应尽可能保持一致，减少平台特定代码。
**组件设计模式（以 Tabs 为例）**:
```tsx
// src/components/Tabs/index.tsx
import React from 'react';
import { View, Text, ScrollView, type ViewProps } from 'react-native';
import { useComponentStyles } from '../../hooks'; // 自定义 Hook，处理样式

export interface TabItem {
  key: string;
  title: string;
  content: React.ReactNode;
}

export interface TabsProps extends ViewProps {
  items: TabItem[];
  activeKey?: string;
  onChange?: (key: string) => void;
}

const Tabs = ({ items, activeKey, onChange, style, ...restProps }: TabsProps) => {
  const componentStyles = useComponentStyles('Tabs', style); // 获取处理后的样式

  return (
    <View style={[componentStyles.container, style]} {...restProps}>
      <ScrollView horizontal showsHorizontalScrollIndicator={false} style={componentStyles.tabBar}>
        {items.map((item) => (
          <Text
            key={item.key}
            style={[
              componentStyles.tab,
              activeKey === item.key && componentStyles.activeTab
            ]}
            onPress={() => onChange?.(item.key)}
          >
            {item.title}
          </Text>
        ))}
      </ScrollView>
      <View style={componentStyles.content}>
        {items.find((item) => item.key === activeKey)?.content}
      </View>
    </View>
  );
};

export default Tabs;
```
**类型定义**: 使用 TypeScript 严格定义 Props 和状态。

## 4. 样式方案

跨端样式处理是关键挑战。

**核心方法**: 使用 `StyleSheet.create` (RN) 和 CSS (Web) 的抽象层。
```tsx
// src/components/Tabs/style.ts
import { StyleSheet } from 'react-native';

export const defaultTabsStyles = StyleSheet.create({
  container: {
    flex: 1,
    width: '100%',
  },
  tabBar: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  tab: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    fontSize: 14,
  },
  activeTab: {
    color: '#1890ff',
    borderBottomWidth: 2,
    borderBottomColor: '#1890ff',
  },
  content: {
    flex: 1,
    padding: 16,
  },
});
```
**样式注入与适配**: 创建一个自定义 Hook (`useComponentStyles`) 来处理样式的合并和平台差异：
```tsx
// src/hooks/useComponentStyles.ts
import { useMemo } from 'react';
import { StyleSheet, type StyleProp } from 'react-native';

export const useComponentStyles = (componentName: string, style?: StyleProp<any>) => {
  return useMemo(() => {
    // 这里可以根据 componentName 获取默认样式，并合并传入的 style
    const defaultStyles = {
      Tabs: { ... }, // 导入你的默认样式
      Button: { ... },
      // ... 其他组件
    };
    const componentDefaultStyles = defaultStyles[componentName] || {};
    return StyleSheet.flatten([componentDefaultStyles, style]);
  }, [componentName, style]);
};
```
**设计 Token**: 将颜色、字体、间距等定义为常量，确保多端一致性。
```tsx
// src/styles/theme.ts
export const theme = {
  colorPrimary: '#1890ff',
  colorText: '#333333',
  spacingSmall: 8,
  spacingMedium: 16,
  fontSizeBase: 14,
  // ... 其他 token
};
```

## 5. 跨平台适配策略

**平台检测**: 使用 `Platform.OS` 和 `Platform.select`。
```tsx
import { Platform } from 'react-native';

const styles = StyleSheet.create({
  container: {
    ...Platform.select({
      web: {
        cursor: 'pointer',
        userSelect: 'none',
      },
      default: {}
    })
  }
});
```
**条件渲染与特定实现**:
对于差异巨大的组件，可以考虑使用 `.android.tsx`, `.ios.tsx`, `.web.tsx` 后缀，构建工具会自动识别。
或者在使用时条件渲染：
```tsx
const MyComponent = () => {
  if (Platform.OS === 'web') {
    return <WebSpecificComponent />;
  }
  return <NativeSpecificComponent />;
};
```
**处理 Web 特有属性**: 在 Web 端，你可能需要添加一些 DOM 属性（如 `data-testid`）。
```tsx
const Tab = ({ title, testID }) => (
  <Text {...(Platform.OS === 'web' ? { 'data-testid': testID } : {})}>
    {title}
  </Text>
);
```

## 6. 工具链与构建配置

**打包工具**: 使用 **Rollup** 或 **Webpack** 打包你的组件库。
**Rollup** 通常更适用于库的打包。
配置 `rollup.config.js`，正确处理 `react-native` 到 `react-native-web` 的别名替换：
```javascript
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import typescript from '@rollup/plugin-typescript';
import peerDepsExternal from 'rollup-plugin-peer-deps-external';

export default {
  input: 'src/index.ts',
  output: [
    {
      file: 'dist/index.js',
      format: 'cjs',
    },
    {
      file: 'dist/index.esm.js',
      format: 'esm',
    },
  ],
  plugins: [
    peerDepsExternal(), // 将 peerDependencies 外部化
    resolve({
      extensions: ['.js', '.jsx', '.ts', '.tsx'],
      // 为 Web 构建时，将 react-native 替换为 react-native-web
      preferBuiltins: false,
      browser: true,
      dedupe: ['react-native', 'react', 'react-dom']
    }),
    commonjs(),
    typescript({ tsconfig: './tsconfig.json' }),
  ],
  external: ['react-native', 'react-native-web'] // 确保这些库不被捆绑
};
```
**Babel 配置**: 在 `.babelrc` 或 `babel.config.js` 中配置 `react-native-web` 插件。
```json
{
  "presets": ["module:metro-react-native-babel-preset"],
  "env": {
    "web": {
      "plugins": ["react-native-web"]
    }
  }
}
```

## 7. 文档与测试

**文档工具**: 使用 **Storybook** 或 **Docusaurus**。Storybook 非常适合交互式地开发和展示组件。
```bash
npx storybook@latest init
```
**编写 Stories** (以 Tabs 为例):
```tsx
// stories/Tabs.stories.tsx
import React from 'react';
import { Tabs } from '../src';

export default {
  title: 'Components/Tabs',
  component: Tabs,
};

const Template = (args) => <Tabs {...args} />;

export const Basic = Template.bind({});
Basic.args = {
  items: [
    { key: '1', title: 'Tab 1', content: <div>Content of Tab 1</div> },
    { key: '2', title: 'Tab 2', content: <div>Content of Tab 2</div> },
    { key: '3', title: 'Tab 3', content: <div>Content of Tab 3</div> },
  ],
  activeKey: '1',
};
```
**测试**: 使用 **Jest** 和 **React Testing Library** (或 **@testing-library/react-native**) 进行单元测试和交互测试。
```tsx
// src/components/Tabs/__tests__/index.test.tsx
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native'; // 或 '@testing-library/react' for web
import Tabs from '../index';

describe('Tabs', () => {
  it('renders correctly', () => {
    const { getByText } = render(<Tabs items={[...]} />);
    expect(getByText('Tab 1')).toBeTruthy();
  });

  it('calls onChange when tab is clicked', () => {
    const mockOnChange = jest.fn();
    const { getByText } = render(<Tabs items={[...]} onChange={mockOnChange} />);
    fireEvent.press(getByText('Tab 2'));
    expect(mockOnChange).toHaveBeenCalledWith('2');
  });
});
```

## 8. 发布与部署

**npm 发布**:
1.  设置 `package.json` 的 `main` (CJS), `module` (ESM), 和 `types` 字段指向打包后的文件。
2.  `npm publish`
**文档部署**: 将 Storybook 或文档网站构建为静态文件，部署到 GitHub Pages, Netlify, Vercel 等平台。
**版本管理**: 遵循语义化版本控制 (SemVer)。

---

构建一个成熟的跨端组件库需要持续的迭代和优化。希望这份方案能为你提供一个清晰的起点。